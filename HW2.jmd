using Evolutionary


n=10
con=3
w=rand(n)
v=rand(n)
x0=BitVector(zeros(n))
f(x)=sum(-(x.*v))
constraint(x)=(sum(w.*x)<=con)

function uflip(recombinant::T) where {T <: BitVector}
    p = mutationRate
    s = length(recombinant)
    check = rand(s).<p
    for i in 1:length(check)
           if check[i]==1
           recombinant[i]=!recombinant[i]
           end
    end
    return recombinant
end

gafu = GA(populationSize=100,mutation=flip,crossover=Evolutionary.uniform(r=0.5))
gafs = GA(populationSize=100,mutation=flip,crossover=singlepoint)
#gaus = GA(populationSize=100,mutation=uflip,crossover=singlepoint)
#gauu = GA(populationSize=100,mutation=uflip,crossover=uniform)

rfu = Evolutionary.optimize(f, x0, constraint, gafu, Evolutionary.Options(iterations=10000))
rfs = Evolutionary.optimize(f, x0, constraint gafs, Evolutionary.Options(iterations=10000))
#rus = Evolutionary.optimize(f, x0, gaus, Evolutionary.Options(iterations=10000))
#ruu = Evolutionary.optimize(f, x0, gauu, Evolutionary.Options(iterations=10000))
