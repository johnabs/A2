using Evolutionary


n=10
con=3
w=rand(n)
v=rand(n)
x0=BitVector(zeros(n))
f(x)=sum(-(x.*v))
constraint(x,c1)=(sum(w.*x)<=c1)

function uflip(recombinant::T) where {T <: BitVector}
    p = mutationRate
    s = length(recombinant)
    check = rand(s).<p
    for i in 1:length(check)
           if check[i]==1
           recombinant[i]=!recombinant[i]
           end
    end
    return recombinant
end

gafu = GA(populationSize=100,mutation=flip,crossover=uniform)
gafs = GA(populationSize=100,mutation=flip,crossover=singlepoint)
gaus = GA(populationSize=100,mutation=uflip,crossover=singlepoint)
gauu = GA(populationSize=100,mutation=uflip,crossover=uniform)

rfu = Evolutionary.optimize(f, x, gafu, Evolutionary.Options(iterations=10000))
rfs = Evolutionary.optimize(f, x, gafs, Evolutionary.Options(iterations=10000))
rus = Evolutionary.optimize(f, x, gaus, Evolutionary.Options(iterations=10000))
ruu = Evolutionary.optimize(f, x, gauu, Evolutionary.Options(iterations=10000))
